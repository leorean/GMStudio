<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mskEnemy</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>5</depth>
  <persistent>0</persistent>
  <parentName>objLiving</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dmg = 1;
hp = 5;
dir = NONE;
vel = .5;
state = WALK;
type = 0;

cx = x+.5*TILE;
cy = y+.5*TILE;

//++++

frame = 0;
fCur = 0;
fMax = 4;
fSpeed = .15;
row = 0;

//++++

ground = noone;
next = noone;
minDist = 9999;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.state == G_PLAY)
{
    cx = x+.5*TILE;
    cy = y+.5*TILE;

    if (next == noone)
    {
        nbrs = getNeighbours(self);
        var choiceIndex = 0;
        var choice;
        
        for (var i = 0; i &lt; 4; i++)
        {
            if (nbrs[i] != noone &amp;&amp; nbrs[i].dist &lt;= minDist)
            {
                minDist = nbrs[i].dist;
                choice[choiceIndex] = nbrs[i];
                choiceIndex++;
            }
        }
                
        next = choice[floor(random(array_length_1d(choice)))];
        
    }
    else
    {
        if (!instance_exists(next))
            next = noone;
        else
        {
            x += sign(next.cx-cx)*vel;
            y += sign(next.cy-cy)*vel;
            
            if (x!=xprevious)
                dir = 1*sign(x-xprevious);
            else
                dir = 2*sign(y-yprevious);
                
            if (abs(cx-next.cx) &lt;=1 &amp;&amp; abs(cy-next.cy) &lt;=1)
                next = noone;
        }        
    }
        
    /*switch (choiceIndex)
    {
        case 0:
            dir = UP;
        break;
        case 1:
            dir = LEFT;
        break;
        case 2:
            dir = DOWN;
        break;
        case 3:
            dir = RIGHT;
        break;
    }*/
    
    /*switch (dir)
    {
        case LEFT:
        case RIGHT:
            x += sign(dir)*vel;
        break;
        case UP:
        case DOWN:
            y += sign(dir)*vel;
        break;
    }*/
    
    /*
    if (walked == 0)
    {
        var nbr = getNeighbours(self);
        var tmpmin = 9999;
        var choice, tmpchoice;
        choice[0] = noone;
        var numchoice = 0;
        
        for (var i = 0; i &lt; array_length_1d(nbr); i++)
        {
            if (nbr[i].dist &lt; tmpmin)
            {
                tmpmin = nbr[i].dist;
                tmpchoice = nbr[i];
            }
        }
                
        while (next == noone)
            next = tmpchoice;//choice[floor(random(numchoice))];
        
        var nextAng = point_direction(cx,cy,next.cx,next.cy)+360;
            
        if (in(nextAng,45+0*90+360,45+1*90+360))
            dir = UP;
        if (in(nextAng,45+1*90+360,45+2*90+360))
            dir = LEFT;
        if (in(nextAng,45+2*90+360,45+3*90+360))
            dir = DOWN;
        if (in(nextAng,45-1*90+360,45+0*90+360))
            dir = RIGHT;
            
        prev = next;
        walked = TILE;
        
    } else //walk in direction
    {
    
        walked = max(walked - vel, 0);
    
        next = instance_place(x,y,objPath);
        
        if (dir == LEFT || dir == RIGHT)
            y = (cy div TILE) * TILE;
        if (dir == UP || dir == DOWN)
            x = (cx div TILE) * TILE;
            
        switch (dir)
        {
        case LEFT:
            x -= vel;
            //next = instance_place(x-TILE-vel,y,objPath);
        break;
        case RIGHT:
            x += vel;
            //next = instance_place(x+TILE+vel,y,objPath);
        break;
        case UP:
            y -= vel;
            //next = instance_place(x,y-TILE-vel,objPath);
        break;
        case DOWN:
            y += vel;
            //next = instance_place(x,y+TILE+vel,objPath);
        break;
        }
    }*/
    
    if (place_meeting(x,y,objGoal) || minDist == 0)
    {
        global.hp = max(global.hp-dmg,0);
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frame = floor(fCur);
fCur = (fCur + fSpeed) % fMax;

switch(dir)
{
    case RIGHT:
        row = 0;
    break;
    case LEFT:
        row = 1;
    break;
    case DOWN:
        row = 2;
    break;
    case UP:
        row = 3;
    break;
}

draw_sprite_part(sprEnemies,-1,frame*TILE + type*4*TILE,row*TILE,TILE,TILE,x,y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
