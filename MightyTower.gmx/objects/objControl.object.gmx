<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>randomize();
mask_index = mskBlock;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>window_set_size(2*WIDTH,2*HEIGHT);
window_center();

if (keyboard_check_pressed(ord('R')))
    game_restart();

if (keyboard_check_pressed(ord('K')))
    with(objEnemy) hp = 0;

if (keyboard_check_pressed(vk_escape) || keyboard_check_pressed(vk_backspace))
    game_end();

global.timer = global.timer+1 % INF;

//++++ velocity management
global.lifeLine = min(max(global.lifeLine, 1),HEIGHT);

if (!global.gameOver)
{
    //++++ global velocity
    //gain speed between waves
    if (!spawnWave)
    {
        //global.yVel = max(2+6*(global.lifeLine/HEIGHT),4);
        if (global.yVel &lt; 4+4*(global.lifeLine/HEIGHT))
            global.yVel = 4+4*(global.lifeLine/HEIGHT);
        else
            global.yVel -= .1;
    }
    else
        global.yVel = min(global.yVel+.1,8);
    
    //++++distance measurement
    global.distance = max(global.distance + global.yVel*.05, global.distance);
    
    if (keyboard_check_pressed(ord('D')))
        global.theme = (global.theme+1) % 7;

    //++++SPAWNING ALGORITHM ETC++++
    if (!instance_exists(objEffectText))
        time = max(time-1,0);
    
    if (spawnWave)
    {
        if (!instance_exists(objEffectText))
        {
            wave++;//choose(1,2); //choose here, depending on depth/theme, which wave spawns

            //++++theme-depth-change:            
            if (global.distance &gt; 1000 &amp;&amp; global.theme == 0) global.theme = 1;
            if (global.distance &gt; 2500 &amp;&amp; global.theme == 1) global.theme = 2;
            if (global.distance &gt; 4000 &amp;&amp; global.theme == 2) global.theme = 3;
            if (global.distance &gt; 7000 &amp;&amp; global.theme == 3) global.theme = 4;
            if (global.distance &gt; 9000 &amp;&amp; global.theme == 4) global.theme = 5;
            if (global.distance &gt; 12000 &amp;&amp; global.theme == 5) global.theme = 6;

            //++++theme dependant obstacles:
            switch(global.theme)
            {
                case 0: //tower: mines from below??
                    //repeat(1+random(2))
                    //    instance_create(1.5*TILE+random(WIDTH-3*TILE),HEIGHT+random(2)*TILE,objMine);                                
                break;
                case 1: //ancient tower:
                break;
                case 2: //cave: boulders from above
                    repeat(2+random(2))
                        instance_create(1.5*TILE+random(WIDTH-3*TILE),-2*TILE,objBoulder);
                break;
                case 3: //crystal cave: crystals from aside
                    for (i = 0; i &lt; 20; i++)
                        instance_create(choose(-TILE,WIDTH+TILE),HEIGHT+i*(5+random(5)*TILE),objCrystal);
                break;
                case 4: //undead tomb: soul skulls that follow the player
                    repeat(2+random(2))
                        instance_create(0,0,objSoul);
                break;
                case 5: //hell.
                break;
                case 6: //the void. endless
                break;
            }
            
            repeat(wave div 1) instance_create(0,0,objEnemySoldier);
            repeat(wave div 2) instance_create(0,0,objEnemyDwarf);
            repeat(wave div 4) instance_create(0,0,objEnemySquid);
            repeat(wave div 8) instance_create(0,0,objEnemyKnightRunner);
            repeat(wave div 12) instance_create(0,0,objEnemyPotato);
            repeat(wave div 15) instance_create(0,0,objEnemyBigSquid);
            repeat(wave div 20) instance_create(0,0,objEnemyBlackKnight);
                        
            switch(wave)
            {
                case 1:
                    //repeat(3) instance_create(0,0,objEnemySoldier);
                    //repeat(2) instance_create(0,0,objEnemyDwarf);
                break;
                case 2:
                    //repeat(2) instance_create(0,0,objEnemyDwarf);
                break;
                case 3:
                    //repeat(2) instance_create(0,0,objEnemyDwarf);
                    //repeat(1) instance_create(0,0,objEnemySquid);
                break;
                case 4:
                break;
                case 5:
                break;
                default: //infinity and beyond
                break;
            }
            
            spawnWave = false;
        }
    } else
    {
        //TODO: reward player with something if he finishes before time?
        if (!instance_exists(objEnemy))
            time = 0;
        
        //if wave is clear, spawn the wave effect, reset timers, hand out goodies (treasure, heart)?
        if (time == 0)
        {
            var et = instance_create(WIDTH/2,HEIGHT+4*TILE,objEffectText);
            et.type = 0;
            
            /*for (i = TILE; i &lt; WIDTH-TILE; i+= TILE)
                for (j = HEIGHT; j &lt; HEIGHT+3*TILE; j+= TILE)
                {
                    instance_create(i,j,objBlock);
                }
            */
            //if (global.theme == 0) global.theme = 1 else global.theme = 0;
            time = maxTime;
            spawnWave = true;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.paused = false;
global.gameOver = false;

global.yVel = 4;
global.yAcc = .0003;
global.yVelMax = 8;

global.distance = 0;
global.coins = 0;
global.timer = 0;

global.theme = 0; //theme

global.shake = false;
shakeTimer = 0;

//wave stuff
spawnWave = true; //if this is true, spawn a new wave of enemies
wave = 0; //the current wave
maxTime = 15*60; // time until next wave
time = maxTime;

//start signal
var et = instance_create(WIDTH/2,HEIGHT+4*TILE,objEffectText);
et.type = 1;

/*
the horizontal line at which the flail has to be... this line should get higher as penalty,
and lower as reward, but overall higher and higher so the game finally ends.
*/
global.lifeLine = 1*HEIGHT/3;
global.lineFriction = .02; //the speed at which the lifeline goes up

flail = instance_create(WIDTH/2,global.lifeLine,objFlail);
instance_create(0,0,objBg);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_black);
draw_set_alpha(1);
view_angle[0] = 0;
/*
draw_text(0,0,global.distance);
draw_text(0,TILE,global.coins);
draw_text(0,2*TILE,global.yVel);
draw_text(0,3*TILE,time);
*/

//draw_line(0,global.lifeLine,WIDTH,global.lifeLine);

//TODO: other condition than player exists...
if (instance_exists(objPlayer))
{

    //DISTANCE
    drawNumber(string(floor(global.distance))+"m",1,1,fa_left,fnt_small);

    //COINS
    draw_sprite_part(sprGraphics,-1,(floor(global.timer*.1)%4)*TILE,0,TILE,TILE,0,TILE);
    drawNumber(global.coins,TILE+1,TILE+3,fa_left,fnt_small);
    
    
    //HP
    draw_sprite_part(sprGraphics,-1,14*TILE,0,6*TILE,TILE,WIDTH/2-3*TILE,0);
    draw_sprite_part(sprGraphics,-1,15*TILE,TILE,4*TILE*(objPlayer.hp/objPlayer.maxHp),TILE,WIDTH/2-2*TILE,0);
    
    //HOUR GLASS
    var tf = min(floor(((1-time/maxTime)*13)),12);
    //sand:
    if (tf &lt; 12)
        draw_sprite(sprParticle,-1,WIDTH-1*TILE,TILE+((global.timer*.5) % 12));
    if (tf &lt; 8)
        draw_sprite(sprParticle,-1,WIDTH-1*TILE-1,TILE+((global.timer*.5+3) % 12));
    if (tf &lt; 10)
        draw_sprite(sprParticle,-1,WIDTH-1*TILE+1,TILE+((global.timer*.5+6) % 12));
    draw_sprite_part(sprGraphics,-1,19*TILE+tf*2*TILE,2*TILE,2*TILE,2*TILE,WIDTH-2*TILE,0);
    
    //TIME
    drawNumber(string(time div 60)+"s",WIDTH-TILE,2*TILE,fa_middle,fnt_small);
    
    //draw_sprite_part(sprGraphics,-1,21*TILE,2*TILE+TILE*(1-time/maxTime),2*TILE,TILE*(time/maxTime),WIDTH-2*TILE,0+TILE*(time/maxTime));

    
    /*
    //top:
    draw_sprite_part(sprGraphics,-1,21*TILE,2*TILE+TILE*(1-time/maxTime),2*TILE,TILE*(time/maxTime),WIDTH-2*TILE,0+TILE*(1-time/maxTime));
    //bottom:
    draw_sprite_part(sprGraphics,-1,21*TILE,3*TILE+TILE*(time/maxTime),2*TILE,TILE*(1-time/maxTime),WIDTH-2*TILE,TILE+TILE*(time/maxTime));
    */
    
    //++++SHAKE SCREEN++++
    if (global.shake)
    {
        shakeTimer = 5;
        global.shake = false;
    }
    if (shakeTimer)
    {
        shakeTimer = max(shakeTimer-1,0);
        view_angle[0] = -2+random(4);
    } else
    {
        view_angle[0] = 0;
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
