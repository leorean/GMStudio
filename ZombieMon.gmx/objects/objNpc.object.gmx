<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mskNpc</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>infectedHp = 100;
hp = 200;

xVel = 0;
yVel = 0;

state = WALK;
statePrev = WALK;
walkDist = 0;
angle = random(360);

target = noone;
fleeFrom = noone;

walkSpeed = .7;
runSpeed = 1.3;

deathTimer = 1*SEC;
delay = 0;

value = 1337;
spawnedCoins = false;

// graphics
dir = NONE;
lastDir = NONE;
frame = 0;
fCur = 0;
fSpeed = .1;
type = 0;
row = 0;
col = 0;

xprev = 0;
yprev = 0;
dst = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// walk around randomly
if (state == WALK)
{
    if (walkDist == 0)
    {
        walkDist = (1+random(2)) * TILE;
        angle = random(360);

    } else
    {
        angle += -6+random(12);
    }
    
    walkDist =  max(walkDist - walkSpeed, 0);
    
    xVel = lengthdir_x(walkSpeed, angle);
    yVel = lengthdir_y(walkSpeed, angle);
    
    if (global.timer % 30 == 0)
    {
        var maxDist = 64;
        for (i = 0; i &lt; instance_number(objNpc); i++)
        {
            var t = instance_find(objNpc, i);
            if (instance_exists(t) &amp;&amp; t != self &amp;&amp; t.state == INFECTED)
            {
                if (distance_to_object(t) &lt; maxDist)
                {
                    maxDist = distance_to_object(t);
                    fleeFrom = t;
                    state = PANIC;
                }
            }
        }
    }
}

// flee in panic
if (state == PANIC)
{
    xVel = lengthdir_x(runSpeed, angle);
    yVel = lengthdir_y(runSpeed, angle);

    walkDist = max(walkDist - runSpeed, 0);
    
    if (walkDist == 0)
    {
        fleeFrom = noone;
        angle = random(360);
        walkDist = TILE;
        var maxDist = 64;
        for (i = 0; i &lt; instance_number(objNpc); i++)
        {
            var t = instance_find(objNpc, i);
            if (instance_exists(t) &amp;&amp; t != self &amp;&amp; t.state == INFECTED)
            {
                if (distance_to_object(t) &lt; maxDist)
                {
                    maxDist = distance_to_object(t);
                    fleeFrom = t;
                }
            }
        }
        if (fleeFrom != noone &amp;&amp; instance_exists(fleeFrom))
        {
            angle = point_direction(fleeFrom.x, fleeFrom.y, x, y);
        } else
            state = WALK;
    }
}

// chase other npcs
if (state == INFECTED)
{    
    var spd = min(.25 * global.huntSpeed + global.huntSpeed * (hp / global.infectedHp), global.huntSpeed);
    walkDist =  max(walkDist - spd, 0);
    xVel = lengthdir_x(spd, angle);
    yVel = lengthdir_y(spd, angle);
    
    if (walkDist == 0)
    {
        target = noone;
        walkDist = 2*TILE;
        
        angle = random(360);
    }

    if (target == noone || !instance_exists(target))
    {
        var maxDist = 99999;
        for (i = 0; i &lt; instance_number(objNpc); i++)
        {
            var t = instance_find(objNpc, i);
            if (instance_exists(t) &amp;&amp; t != self &amp;&amp; t.state != INFECTED &amp;&amp; t.state != DIE)
            {
                if (distance_to_object(t) &lt; maxDist)
                {
                    target = t;
                    maxDist = distance_to_object(t);
                }
            }
        }
    }
    else
    {
        angle = point_direction(x, y, target.x, target.y);

        // infect others
        if (collision_rectangle(x, y, x+TILE, y+TILE, target, false, true))
        {
            if (delay == 0)
            {
                target.hp = max(target.hp - global.dmg, 0);
                delay = global.delay;
                hp = min(hp + global.leech, global.infectedHp);
            }
            if (target.hp == 0)
            {
                target.hp = global.infectedHp;
                
                // chance to infect
                var rnd = random(1);
                if (rnd &gt;= global.infectChance)
                    target.state = INFECTED;
                else
                    target.state = DIE;
                
                spawnCoins(value, x + 8, y + 8);
                    
                target = noone;                
            }
        }
    }
    
    delay = max(delay - 1, 0);
    
    hp = max(hp - 1, 0);
    if (hp == 0)
    {
        state = DIE;
    }
}

// die after infection
if (state == DIE)
{

    /*if (!spawnedCoins)
        spawnCoins(value, x + 8, y + 8);
    spawnedCoins = true;*/
    
    hp = 0;
    xVel = 0;
    yVel = 0;
    
    deathTimer = max(deathTimer - 1, 0);
    
    if (deathTimer == 0)
    {
        instance_destroy();
    }
}

if (!place_meeting(x + xVel, y, objSolid) &amp;&amp; in(x + xVel, 0, room_width - TILE))
    x += xVel;
else
{
    xVel = 0;
    target = noone;
}
if (!place_meeting(x, y + yVel, objSolid) &amp;&amp; in(y + yVel, 0, room_height - TILE))
    y += yVel;
else
{
    yVel = 0;
    target = noone;    
}

// cosmetic bullshit
if (dst == 0)
{
    dir = angleToDir(point_direction(xprev, yprev, x, y));

    xprev = x;
    yprev = y;
    dst = 3;
} else
    dst = max(dst-1, 0);

if (state == DIE)
    dir = DOWN;
    
if ((state == INFECTED || state == DIE) &amp;&amp; statePrev != state)
    instance_create(x+8, y+8, objEffect);

statePrev = state;
    
depth = room_height - y + 30;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>fCur = (fCur + fSpeed) % 2;
frame = floor(fCur);

switch(state)
{
    case WALK:
        col = 0;
        fSpeed = .1;
    break;
    case PANIC:
        col = 2;
        fSpeed = .2;
    break;
    case INFECTED:
        fSpeed = .15;
        col = 4;
    break;
    case DIE:
        fSpeed = .15;
        col = 6;
    break;
}

switch(dir)
{
    case DOWN:
        row = 0;
    break;
    case UP:
        row = 1;
    break;
    case LEFT:
        row = 2;
    break;
    case RIGHT:
        row = 3;
    break;
}

draw_sprite_part(sprNpc, -1, col * TILE + frame * TILE, row * TILE, TILE, TILE, x, y);

//draw_text(x, y-TILE, string(xVel) + ", " + string(yVel));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
