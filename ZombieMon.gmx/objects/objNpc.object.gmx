<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mskNpc</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>infectedHp = global.infectedHp;
hp = global.npcHp;//200;

xVel = 0;
yVel = 0;

spawned = false;

state = WALK;
statePrev = WALK;
walkDist = 0;
angle = random(360);

target = noone;
fleeFrom = noone;

walkSpeed = .7;
runSpeed = 1.25;
boost = .5; //additional speed when transitioning

deathTimer = 3*SEC;
delay = 0;

value = global.value;
spawnedCoins = false;

// graphics
type = irandom(8);

dir = NONE;
lastDir = NONE;
frame = 0;
fCur = 0;
fSpeed = .1;
row = 0;
col = 0;

xprev = 0;
yprev = 0;
dst = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//infector!
if (state != DIE &amp;&amp; state != INFECTED)
{
    if(place_meeting(x, y, objInfector))
    {
        //instance_create(x + .5*TILE, y+TILE, objLightning);
        state = INFECTED;
        hp = global.infectedHp;
        global.kills++;
    }
}

// walk around randomly
if (state == WALK)
{
    if (walkDist == 0)
    {
        walkDist = (1+random(2)) * TILE;
        if (spawned)
            angle = random(360);

    } else
    {
        if (spawned)
            angle += -6+random(12);
    }
        
    walkDist =  max(walkDist - walkSpeed, 0);
    
    xVel = lengthdir_x(walkSpeed, angle);
    yVel = lengthdir_y(walkSpeed, angle);
    
    if (global.timer % 30 == 0)
    {
        var maxDist = 64;
        for (i = 0; i &lt; instance_number(objNpc); i++)
        {
            var t = instance_find(objNpc, i);
            if (instance_exists(t) &amp;&amp; t != self &amp;&amp; t.state == INFECTED)
            {
                if (distance_to_object(t) &lt; maxDist)
                {
                    maxDist = distance_to_object(t);
                    fleeFrom = t;
                    state = PANIC;
                }
            }
        }
    }
}

// flee in panic
if (state == PANIC)
{
    var _rnspd = max(.5, runSpeed * (hp/global.npcHp));
    xVel = lengthdir_x(_rnspd, angle);
    yVel = lengthdir_y(_rnspd, angle);

    walkDist = max(walkDist - runSpeed, 0);
    
    if (walkDist == 0)
    {
        fleeFrom = noone;
        if (spawned)
            angle = random(360);
        walkDist = TILE;
        var maxDist = 64;
        for (i = 0; i &lt; instance_number(objNpc); i++)
        {
            var t = instance_find(objNpc, i);
            if (instance_exists(t) &amp;&amp; t != self &amp;&amp; t.state == INFECTED)
            {
                if (distance_to_object(t) &lt; maxDist)
                {
                    maxDist = distance_to_object(t);
                    fleeFrom = t;
                }
            }
        }
        if (fleeFrom != noone &amp;&amp; instance_exists(fleeFrom))
        {
            if (spawned &amp;&amp; in(x, TILE, room_width-2*TILE) &amp;&amp; in(y, TILE, room_height-2*TILE))
                angle = point_direction(fleeFrom.x, fleeFrom.y, x, y)
                    - 15 + random(30);
        } else
            state = WALK;         
    }
}

// chase other npcs
if (state == INFECTED)
{
    var spd = min(.25 * global.huntSpeed + global.huntSpeed * (hp / global.infectedHp), 
        global.huntSpeed)
        + boost;

    boost = max(boost - .01, 0);
    
    delay = max(delay - 1, 0);
    
    walkDist =  max(walkDist - spd, 0);
    xVel = lengthdir_x(spd, angle);
    yVel = lengthdir_y(spd, angle);
    
    if (walkDist == 0)
    {
        target = noone;
        walkDist = 2*TILE;
        
        angle = random(360);
    }

    if (target == noone || !instance_exists(target))
    {
        var maxDist = 99999;
        for (i = 0; i &lt; instance_number(objNpc); i++)
        {
            var t = instance_find(objNpc, i);
            if (instance_exists(t) &amp;&amp; t != self &amp;&amp; t.state != INFECTED &amp;&amp; t.state != DIE)
            {
                if (distance_to_object(t) &lt; maxDist
                 &amp;&amp; (t.fleeFrom == id || t.fleeFrom == noone || instance_number(objNpc) &lt;= 2)
                 &amp;&amp; !collision_line(x+8,y+8,t.x+8,t.y+8,objSolid,false,true)
                 &amp;&amp; t.spawned)
                {
                    target = t;
                    maxDist = distance_to_object(t);
                }
            }
        }
    }
    else
    {
        angle = point_direction(x, y, target.x, target.y);

        // infect others
        if (collision_rectangle(x + xVel, y + yVel, x+TILE+xVel, y+TILE+yVel, target, false, true))
        {
            if (delay == 0)
            {
                target.hp = max(target.hp - global.dmg, 0);
                
                spawnBlood(target.x+8, target.y+8, 2+random(3));
                
                /*var _txt = instance_create(x+8, y, objText);
                _txt.color = c_red;
                _txt.text = global.dmg;*/
                
                //hp = min(hp + global.leech, global.infectedHp);

                delay = global.delay;
            }
            if (target.hp == 0)
            {
                target.hp = global.infectedHp;
                
                // chance to infect
                var rnd = random(1);
                if (rnd &gt;= global.infectChance)
                    target.state = INFECTED;
                else
                    target.state = DIE;
                
                global.kills++;
                spawnCoins(value, x + 8, y + 8);
                
                spawnBlood(target.x+8, target.y+8, 15);
                
                target = noone;                
            }
        }
    }
    
    hp = max(hp - 1, 0);
    if (hp == 0)
    {
        state = DIE;
    }
}

// die after infection
if (state == DIE)
{
    
    hp = 0;
    xVel = 0;
    yVel = 0;
    
    deathTimer = max(deathTimer - 1, 0);
    
    if (deathTimer == 0)
    {
        instance_destroy();
    }
}

if (!spawned)
{
    x = max(-TILE,min(x, room_width));
    y = max(-TILE,min(y, room_height));
    if (in(x,0,room_width-TILE) &amp;&amp; in(y,0,room_height-TILE) 
    &amp;&amp; !place_meeting(x, y, objSolid))
        spawned = true;
    
    x += xVel;
    y += yVel;
    
} else
{
    if (!place_meeting(x + xVel, y, objSolid) &amp;&amp; in(x + xVel, 0, room_width - TILE))
        x += xVel;
    else
    {
        xVel = 0;
    }
    if (!place_meeting(x, y + yVel, objSolid) &amp;&amp; in(y + yVel, 0, room_height - TILE))
        y += yVel;
    else
    {
        yVel = 0;
    }
}

// cosmetic bullshit
if (dst == 0)
{
    dir = angleToDir(point_direction(xprev, yprev, x, y));

    xprev = x;
    yprev = y;
    dst = 3;
} else
    dst = max(dst-1, 0);

if (state == DIE)
    dir = DOWN;
    
if ((state == INFECTED || state == DIE) &amp;&amp; statePrev != state)
{
    fCur = 0;
    instance_create(x+8, y+8, objEffect);
}

statePrev = state;
    
depth = room_height - y + 30;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_alpha(1);

if (state != DIE)
    fCur = (fCur + fSpeed) % 2;
else
    fCur = (fCur + fSpeed) % 4;
    //fCur = min((fCur + fSpeed), 3);

frame = floor(fCur);

switch(state)
{
    case WALK:
        col = 0;
        fSpeed = .1;
    break;
    case PANIC:
        col = 2;
        fSpeed = .2;
    break;
    case INFECTED:
        fSpeed = .15;
        col = 4;
    break;
    case DIE:
        fSpeed = .15;
        col = 6;
    break;
}

switch(dir)
{
    case DOWN:
        row = 0 + 4*type;
    break;
    case UP:
        row = 1 + 4*type;
    break;
    case LEFT:
        row = 2 + 4*type;
    break;
    case RIGHT:
        row = 3 + 4*type;
    break;
}

//HP bar
if ((state == PANIC || state == WALK) &amp;&amp; hp &lt; global.npcHp)
{
    draw_sprite_part(sprHud, -1, 0, 0, TILE, 1, x, y - 1);
    draw_sprite_part(sprHud, -1, 0, 1, TILE * hp/global.npcHp, 1, x, y - 1);
}

if (state == INFECTED || state == DIE)
    type = 0;
    
draw_sprite_part(sprNpc, -1, col * TILE + frame * TILE, row * TILE, TILE, TILE, x, y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
