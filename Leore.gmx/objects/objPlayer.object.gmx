<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mskPlayer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>phy_rotation = 0;
phy_fixed_rotation = true;

image_speed = 0;

global.player = id;

xPrev = x;
yPrev = y;

isJumped = false;

rope = noone;
ropeEnd = noone;
ropeNew = noone;

state = IDLE;
statePrev = state;

//+++animation
w = abs(bbox_left - bbox_right);
h = abs(bbox_top - bbox_bottom);

dir = RIGHT;

frame = 0;
row = 0;
fSpeed = 0;
fMax = 3;
fCur = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//++++input
if (global.hasControl)
{
    keyL = keyboard_check(vk_left);
    keyR = keyboard_check(vk_right);
    keyU = keyboard_check(vk_up);
    keyD = keyboard_check(vk_down);
    keyUPressed = keyboard_check_pressed(vk_up);
    keyActionPressed = keyboard_check_pressed(ord('A'));
    keyActionReleased = keyboard_check_released(ord('A'));
}
else
{
    keyL = false;
    keyR = false;
    keyU = false;
    keyD = false;
    keyActionPressed = false;
    keyActionReleased = false;

}

//++++flag control
//collision_line(x-TILE/2+2,y+TILE/2,x+TILE/2-2,y+TILE/2,objCollider,true,true)
var colL, colR, colD;

colL = collision_point(bbox_left-1,y,objCollider,true,true);
colR = collision_point(bbox_right+1,y,objCollider,true,true);
colD = collision_point(x,bbox_bottom+1,objCollider,true,true) ||
    collision_line(bbox_left,bbox_bottom+1,bbox_right,bbox_bottom+1,objSlope,true,true);//collision_point(x,bbox_bottom+1,objCollider,true,true);
colU = collision_point(x,bbox_top-1,objCollider,true,true);

onGround = //(phy_speed_y &gt;= 0 &amp;&amp;
    ((physics_test_overlap(x,y+1,0,objCollider)
        || physics_test_overlap(x,y+3,0,objSlope))
    &amp;&amp; (colD));
    //&amp;&amp; (((!colL || colD) &amp;&amp; !colU) &amp;&amp; ((!colR || colD) &amp;&amp; !colU)));
    //&amp;&amp; collision_line(x-TILE/2+2,y+TILE/2,x+TILE/2-2,y+TILE/2,objCollider,true,true))
    

    
if (onGround)
    isJumped = false;

//++++movement
if (state == IDLE || state == JUMP || state == RUN)
{
    if (keyL &amp;&amp; !keyR  &amp;&amp; phy_speed_x &gt; -2)
    {
        physics_apply_force(x,y,-300,-300*onGround);
        if (onGround) state = RUN;
    }
    
    if (keyR &amp;&amp; !keyL &amp;&amp; phy_speed_x &lt; 2)
    {
        physics_apply_force(x,y,300,-300*onGround);
        if (onGround) state = RUN;
    }

    if (keyL &amp;&amp; phy_speed_x &lt; 0)
        dir = LEFT;
    if (keyR &amp;&amp; phy_speed_x &gt; 0)
        dir = RIGHT;

    if (keyL || keyR)
    {
        if (onGround)
            state = RUN;
        else
            state = JUMP;
    }
    
    if (onGround)
    {
        show_debug_message(abs(phy_position_x-phy_position_xprevious));
        if (!keyL &amp;&amp; abs(phy_position_x-phy_position_xprevious) &gt;= 0)
        {
            if (sign(phy_position_x-phy_position_xprevious) &lt;= 0)
                phy_speed_x = min(phy_speed_x + .2, 0);
        }
        if (!keyR &amp;&amp; abs(phy_position_x-phy_position_xprevious) &gt;= 0)
        {
            if (sign(phy_position_x-phy_position_xprevious) &gt;= 0)
            phy_speed_x = max(phy_speed_x - .2, 0);
        }
    } else
        show_debug_message("not onground");
        
    if (!keyL &amp;&amp; !keyR &amp;&amp; onGround)
    {
        if (abs(ceil(phy_speed_x)) == 0)
            state = IDLE;
        else
            state = RUN;
        
    }
}

//++++jumping
if (state != ATTACK)
{
    if (keyUPressed)
    {
        if (!isJumped)
        {
            //physics_apply_impulse(x,y,0,-230);
            phy_speed_y = -3.2;
            isJumped = true;
            state = JUMP;
        }
    }
}

//ATTACKING
if (keyActionPressed)
{

}

if (keyActionReleased)
{
}

//++++ end routine
if (state != statePrev)
    fCur = 0;
statePrev = state;
xPrev = x;
yPrev = y;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objEnemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>enemy = instance_place(x,y,objEnemy);
if (enemy != noone &amp;&amp; instance_exists(enemy))
{
    physics_apply_impulse(x,y,sign(enemy.x-x)*-30,-50);
    //phy_speed_x = sign(enemy.x-x) * 2;
    //phy_speed_y = -2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objCollider">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>fCur = (fCur + fSpeed) mod (fMax + 1);
frame = floor(fCur);

switch(state)
{
    case IDLE:
        fSpeed = .1;
        row = 0;
    break;
    case RUN:
        fSpeed = .2;
        row = 1;
    break;
    case JUMP:
        fSpeed = .1;
        row = 2;
    break;
    case DIE:
        
    break;
    case ATTACK:
        
    break;
    case HURT:
        
    break;
    
}

if (dir == RIGHT)
    draw_sprite_part(global.sprPlayer,-1,frame*TILE,row*TILE,TILE,TILE,(x-TILE/2),(y-TILE/2)-2);
if (dir == LEFT)
    draw_sprite_part_ext(global.sprPlayer,-1,frame*TILE,row*TILE,TILE,TILE,(x+TILE/2),(y-TILE/2)-2,-1,1,c_white,1);

/*draw_set_color(c_yellow);
draw_point(bbox_right,y);
draw_point(bbox_left,y);
draw_point(x,bbox_top);
draw_point(x,bbox_bottom);*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>-1</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>2</PhysicsObjectShape>
  <PhysicsObjectDensity>10</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.100000001490116</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>-1</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>12,12</point>
    <point>20,12</point>
    <point>20,21</point>
    <point>16,22</point>
    <point>12,21</point>
  </PhysicsShapePoints>
</object>
