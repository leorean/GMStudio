<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mskPlayer</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//
starty = view_yview[0];
//y = view_yview[0]-2*TILE;

cx = x;
cy = y;

dir = RIGHT;
state = IDLE;
statePrev = state;
xVel = 0;
yVel = 0;
yGrav = .3;

fCur = 0;
fMax = 4;
frame = 0;
fSpeed = 0;

onGround = false;
onLadder = false;
attacking = false;
attackDelay = 0; //cooldown to shoot
hasAttacked = false;
charge = 0;
maxCharge = .6*SEC;
jumped = false;
jumpDist = false;

invincible = 0;
maxInvincible = 1*SEC;

maxHp = 30;
hp = maxHp;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.state == G_START)
{
    /*if (starty &lt; y &amp;&amp; objControl.fade &lt;= 0)
    {
        state = SPAWN;
        starty = clamp(starty+8,view_yview[0]-2*TILE,y);
        fCur = 0;
    }
    if (starty == y)
    {
        if (fCur &gt;= (fMax-fSpeed))
        {
            global.state = G_PLAY;
            state = IDLE;
        }
    }*/

    global.state = G_PLAY;
    
}
if (global.state == G_CAMMOVE) //reset certain stuff
{
    //charged = 0;
    //attackDelay = 0;
    //hasAttacked = false;
}
if (global.state == G_PLAY)
{
    cx = x+.5*TILE;
    cy = y+.5*TILE;
    //++++input++++
    var kLeft = ((keyboard_check(vk_left) &amp;&amp; !keyboard_check(vk_right))) || (instance_exists(global.dPad) &amp;&amp; global.dPad.kLeft &amp;&amp; global.dPad.forceX &gt;= .35);
    var kRight = ((keyboard_check(vk_right) &amp;&amp; !keyboard_check(vk_left))) || (instance_exists(global.dPad) &amp;&amp; global.dPad.kRight &amp;&amp; global.dPad.forceX &gt;= .35);
    var kUp = keyboard_check(vk_up) || (instance_exists(global.dPad) &amp;&amp; global.dPad.kUp &amp;&amp; global.dPad.forceY &gt;= .35);
    var kDown = keyboard_check(vk_down) || (instance_exists(global.dPad) &amp;&amp; global.dPad.kDown &amp;&amp; global.dPad.forceY &gt;= .35);
    var kA = keyboard_check(ord('A')) || (instance_exists(global.btnA)&amp;&amp; global.btnA.pressing);
    var kAPressed = keyboard_check_pressed(ord('A')) || (instance_exists(global.btnA)&amp;&amp; global.btnA.pressed);
    var kB = keyboard_check(ord('S')) || (instance_exists(global.btnB)&amp;&amp; global.btnB.pressing);
    var kBPressed = keyboard_check_pressed(ord('S')) || (instance_exists(global.btnB)&amp;&amp; global.btnB.pressed);
    //var kBReleased = keyboard_check_released(ord('S')) || (instance_exists(global.btnB)&amp;&amp; global.btnB.released);
    
    var spd = 1.5;
    var spdX = spd; var spdY = spd;
    if (os_type == os_android || global.dPad.dev &gt; -1)
    {
        spdX = spd*objDPad.forceX;
        spdY = spd*objDPad.forceY;
    }
    
    //++++routine++++
    
    enemy = instance_place(x,y,objEnemy);
    
    if (instance_exists(enemy) &amp;&amp; !invincible)
    {
        var ang = point_direction(enemy.cx,enemy.cy,cx,cy);
        xVel = lengthdir_x(-2,ang);
        yVel = lengthdir_y(-2,ang);
        invincible = maxInvincible;
        hp = max(hp-enemy.dmg,0);
        enemy = noone;
    }
    
    invincible = max(invincible - 1, 0);
    if (invincible &gt; .5*maxInvincible || state == DEAD)
    {
        kLeft = false; kRight = false; kUp = false; kDown = false; kA = false; kB = false;
        kAPressed = false; kBPressed = false;
    }
    
    //++++ATTACK ROUTINE++++
    /*
    attackDelay = max(attackDelay-1,0);
    attacking = max(attacking-1,0);

    if (!kAttack &amp;&amp; charge &lt; maxCharge)
        charge = 0;
    if (kAttack &amp;&amp; !attackDelay)
    {
        charge = min(charge+1,maxCharge);
        if (!attackDelay &amp;&amp; !hasAttacked)
            switch (global.attackType)
            {
                case 0:
                    if (charge &lt; maxCharge) //NORMAL SHOT
                    {
                        var proj = instance_create(x+sign(dir)*TILE,cy,objPlayerProj1);
                        proj.xVel = sign(dir)*4;
                        proj.dir = dir;
                        proj.dmg = 3;
                        proj.type = 0;
                        attackDelay = 10;
                    } else //CHARGED SHOT
                    {
                        var proj = instance_create(x+sign(dir)*TILE,cy,objPlayerProj1);
                        proj.xVel = sign(dir)*3;
                        proj.dir = dir;
                        proj.dmg = 12;
                        proj.type = 1;
                        attackDelay = 10;
                        charge = 0;
                    }
                break;
            }
        attacking = attackDelay + 10;
        hasAttacked = true;
    }
    
    if (kAttackReleased)
        hasAttacked = false;
    */
    
    //++++move
    
    if (state == IDLE || state == WALK)
    {
        if (kLeft) {dir = LEFT; xVel = -spdX; state = WALK;}
        if (kRight) {dir = RIGHT; xVel = spdX; state = WALK;}
        if (kUp) {dir = UP; yVel = -spdY; state = WALK;}
        if (kDown) {dir = DOWN; yVel = spdY; state = WALK;}
        
        if (state == WALK &amp;&amp; !kLeft &amp;&amp; !kRight &amp;&amp; !kUp &amp;&amp; !kDown) state = IDLE;
    }
    if (!kLeft &amp;&amp; !kRight &amp;&amp; (invincible &lt; 30)) xVel = 0;
    if (!kUp &amp;&amp; !kDown &amp;&amp; (invincible &lt; 30)) yVel = 0;
        
    //++++physics++++
    
    xVel = sign(xVel)*min(abs(xVel),5);
    yVel = sign(yVel)*min(abs(yVel),5);
    
    if (!place_meeting(x+xVel,y,objSolid))
        x += xVel;
    else
        xVel = 0;
    if (!place_meeting(x,y+yVel,objSolid))
        y += yVel;
    else
        yVel = 0;
    
            
    x = clamp(x,0,room_width);
    y = clamp(y,0,room_height+2*TILE);
    if (state != statePrev)
        fCur = 0;
    statePrev = state;
    
    //++++death++++
    if (hp &lt;= 0)
    {
        state = DEAD;
        effectDead(x,y+TILE);
        
        global.state = G_GAMEOVER;
    }

    deathTimer = 3*SEC;
}//end play
if (global.state == G_GAMEOVER)
{
    deathTimer = max(deathTimer-1,0);
    if (!deathTimer)
    {
        room_restart();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != statePrev)
    fCur = 0;

var xDraw = floor(x);
var yDraw = floor(y);

var frame, row, sRow;
    
switch (dir)
{
    case UP:
        row = 0;
    break;
    case DOWN:
        row = 1;
    break;
    case LEFT:
        row = 2;
    break;
    case RIGHT:
        row = 3;
    break;
    
}

switch(state)
{
    case IDLE:
        fSpeed = .08;
        sRow = 0;
        fMax = 4;
    break;
    case WALK:
        sRow = 1;
        fSpeed = .13;
        fMax = 4;
    break;
    case ATTACK:
        sRow = 2;
        fSpeed = .2;
        fMax = 3;
    break;

}

fCur = (fCur+fSpeed) % fMax;
frame = floor(fCur);

draw_sprite_part(sprPlayer,-1,frame*TILE,row*TILE+4*sRow*TILE,TILE,TILE,xDraw,yDraw);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
